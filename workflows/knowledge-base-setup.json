{
  "name": "Sofia Knowledge Base - RAG Setup (Google Drive)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": []
        },
        "options": {}
      },
      "id": "manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [220, 340]
    },
    {
      "parameters": {
        "content": "## RAG Knowledge Base Setup (Google Drive)\n\nThis workflow loads and embeds knowledge base documents from Google Drive into Qdrant vector store.\n\n### Setup Required:\n1. **Google Drive Folder**: Create a folder in Google Drive for knowledge base documents\n2. **Configure Folder ID**: Update the 'List Files from Google Drive' node with your folder ID\n3. **Supported formats**: .md, .txt, .pdf, Google Docs\n\n### Steps:\n1. **Trigger manually** to start the process\n2. **List all files** from Google Drive folder\n3. **Download and parse** each document\n4. **Split into chunks** for better retrieval\n5. **Generate embeddings** using OpenAI\n6. **Store in Qdrant** vector database\n\n### Run this workflow:\n- After adding/modifying knowledge base documents in Drive\n- To rebuild the entire vector store\n- Initial setup of the RAG system",
        "width": 400,
        "height": 420
      },
      "id": "sticky-note",
      "name": "Instructions",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [220, -100]
    },
    {
      "parameters": {
        "operation": "list",
        "folderId": {
          "__rl": true,
          "value": "={{ $env.GOOGLE_DRIVE_KNOWLEDGE_FOLDER_ID }}",
          "mode": "id"
        },
        "filter": {},
        "options": {
          "fields": ["id", "name", "mimeType", "modifiedTime", "description"]
        }
      },
      "id": "google-drive-list",
      "name": "List Files from Google Drive",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [440, 340],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "google-drive-creds",
          "name": "Google Drive OAuth"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Filter for supported file types and extract metadata\nconst items = $input.all();\nconst supportedMimeTypes = [\n  'text/markdown',\n  'text/plain',\n  'text/x-markdown',\n  'application/vnd.google-apps.document', // Google Docs\n  'application/pdf'\n];\n\n// Also filter by file extension as fallback\nconst supportedExtensions = ['.md', '.txt', '.pdf'];\n\nconst filteredFiles = items.filter(item => {\n  const mimeType = item.json.mimeType || '';\n  const fileName = item.json.name || '';\n  const extension = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();\n  \n  return supportedMimeTypes.includes(mimeType) || \n         supportedExtensions.includes(extension) ||\n         mimeType.includes('google-apps.document');\n}).map(item => ({\n  json: {\n    fileId: item.json.id,\n    fileName: item.json.name,\n    mimeType: item.json.mimeType,\n    modifiedTime: item.json.modifiedTime,\n    description: item.json.description || '',\n    // Extract category from folder path or description\n    category: extractCategory(item.json.name, item.json.description),\n    priority: item.json.description?.includes('priority:high') ? 'high' : 'normal'\n  }\n}));\n\nfunction extractCategory(fileName, description) {\n  // Try to extract category from description field\n  if (description) {\n    const categoryMatch = description.match(/category:\\s*(\\w+)/i);\n    if (categoryMatch) return categoryMatch[1].toLowerCase();\n  }\n  \n  // Infer from filename patterns\n  const name = fileName.toLowerCase();\n  if (name.includes('faq') || name.includes('question')) return 'faq';\n  if (name.includes('treatment') || name.includes('protocol') || name.includes('tirzepatide')) return 'treatments';\n  if (name.includes('clinic') || name.includes('about') || name.includes('institutional')) return 'institutional';\n  if (name.includes('objection') || name.includes('price')) return 'objections';\n  if (name.includes('compliance') || name.includes('disclaimer') || name.includes('legal')) return 'compliance';\n  \n  return 'general';\n}\n\nif (filteredFiles.length === 0) {\n  return [{ json: { error: 'No supported files found in the Google Drive folder', supportedTypes: supportedMimeTypes } }];\n}\n\nreturn filteredFiles;"
      },
      "id": "filter-files",
      "name": "Filter Supported Files",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 340]
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.fileId }}",
          "mode": "id"
        },
        "options": {
          "googleFileConversion": {
            "conversion": {
              "docsToFormat": "text/plain"
            }
          }
        }
      },
      "id": "google-drive-download",
      "name": "Download File",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [880, 340],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "google-drive-creds",
          "name": "Google Drive OAuth"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse the downloaded file and extract content\nconst items = $input.all();\nconst allChunks = [];\n\nfor (const item of items) {\n  // Get binary data from downloaded file\n  const binaryData = item.binary?.data;\n  let content = '';\n  \n  if (binaryData) {\n    // Convert binary to string\n    content = Buffer.from(binaryData.data, 'base64').toString('utf-8');\n  } else if (item.json.content) {\n    content = item.json.content;\n  }\n  \n  // Get file metadata from previous node\n  const fileMetadata = $('Filter Supported Files').item.json;\n  const fileName = fileMetadata.fileName;\n  const category = fileMetadata.category;\n  const priority = fileMetadata.priority;\n  \n  // Remove frontmatter (YAML between ---) if present\n  let cleanContent = content;\n  const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---\\n/);\n  if (frontmatterMatch) {\n    cleanContent = content.replace(frontmatterMatch[0], '').trim();\n  }\n  \n  // Split content into sections by headings\n  const sections = [];\n  const lines = cleanContent.split('\\n');\n  let currentSection = { title: fileName.replace(/\\.[^/.]+$/, ''), content: '', level: 0 };\n  \n  for (const line of lines) {\n    // Check if line is a heading\n    const headingMatch = line.match(/^(#{1,4})\\s+(.+)/);\n    \n    if (headingMatch) {\n      // Save previous section if it has content\n      if (currentSection.content.trim()) {\n        sections.push({ ...currentSection });\n      }\n      // Start new section\n      currentSection = {\n        title: headingMatch[2].trim(),\n        content: '',\n        level: headingMatch[1].length\n      };\n    } else {\n      // Add line to current section\n      currentSection.content += line + '\\n';\n    }\n  }\n  \n  // Don't forget last section\n  if (currentSection.content.trim()) {\n    sections.push(currentSection);\n  }\n  \n  // Create chunks with metadata\n  const chunks = sections\n    .filter(s => s.content.trim().length > 20) // Filter out empty/tiny sections\n    .map((section, index) => ({\n      content: `## ${section.title}\\n\\n${section.content.trim()}`,\n      metadata: {\n        source: `gdrive:${fileName}`,\n        source_type: 'google_drive',\n        file_id: fileMetadata.fileId,\n        category: category,\n        priority: priority,\n        section: section.title,\n        chunk_index: index,\n        modified_time: fileMetadata.modifiedTime\n      }\n    }));\n  \n  // If no good sections found, use whole content as one chunk\n  if (chunks.length === 0 && cleanContent.trim().length > 20) {\n    chunks.push({\n      content: cleanContent.trim(),\n      metadata: {\n        source: `gdrive:${fileName}`,\n        source_type: 'google_drive',\n        file_id: fileMetadata.fileId,\n        category: category,\n        priority: priority,\n        section: 'full_document',\n        chunk_index: 0,\n        modified_time: fileMetadata.modifiedTime\n      }\n    });\n  }\n  \n  allChunks.push(...chunks);\n}\n\nreturn allChunks.map(c => ({ json: c }));"
      },
      "id": "parse-document",
      "name": "Parse & Chunk Document",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 340]
    },
    {
      "parameters": {
        "mode": "insert",
        "qdrantCollection": {
          "__rl": true,
          "value": "sofia_knowledge",
          "mode": "list"
        },
        "options": {
          "clearCollection": false
        }
      },
      "id": "qdrant-insert",
      "name": "Insert into Qdrant",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreQdrant",
      "typeVersion": 1,
      "position": [1320, 340],
      "credentials": {
        "qdrantApi": {
          "id": "qdrant-creds",
          "name": "Qdrant"
        }
      }
    },
    {
      "parameters": {
        "model": "text-embedding-3-small",
        "options": {}
      },
      "id": "embeddings",
      "name": "OpenAI Embeddings",
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [1320, 540],
      "credentials": {
        "openAiApi": {
          "id": "openai-creds",
          "name": "OpenAI"
        }
      }
    },
    {
      "parameters": {
        "chunkSize": 1000,
        "chunkOverlap": 100,
        "options": {}
      },
      "id": "text-splitter",
      "name": "Recursive Text Splitter",
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [1460, 540]
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $json.content }}",
        "options": {
          "metadata": "={{ $json.metadata }}"
        }
      },
      "id": "document-loader",
      "name": "Default Data Loader",
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [1600, 540]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "aggregate",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [1540, 340]
    },
    {
      "parameters": {
        "jsCode": "// Summarize the embedding results\nconst items = $input.all();\nconst results = items.flatMap(i => i.json.data || [i.json]);\n\nconst summary = {\n  success: true,\n  source: 'Google Drive',\n  totalChunksProcessed: results.length,\n  message: `Successfully embedded ${results.length} document chunks from Google Drive into Qdrant vector store 'sofia_knowledge'.`,\n  timestamp: new Date().toISOString()\n};\n\nreturn [{ json: summary }];"
      },
      "id": "summary",
      "name": "Generate Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, 340]
    },
    {
      "parameters": {
        "content": "=## Embedding Complete!\n\n**Source:** {{ $json.source }}\n\n{{ $json.message }}\n\nTimestamp: {{ $json.timestamp }}",
        "width": 320,
        "height": 160
      },
      "id": "result-note",
      "name": "Result",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1980, 320]
    },
    {
      "parameters": {
        "content": "## Google Drive Setup\n\n### 1. Get Folder ID\nOpen your Google Drive folder and copy the ID from the URL:\n`https://drive.google.com/drive/folders/YOUR_FOLDER_ID`\n\n### 2. Set Environment Variable\nAdd to n8n environment:\n```\nGOOGLE_DRIVE_KNOWLEDGE_FOLDER_ID=your_folder_id_here\n```\n\nOr manually update the 'List Files from Google Drive' node.\n\n### 3. File Naming Convention\nUse descriptive names to auto-categorize:\n- `faq_*.md` → FAQ category\n- `treatment_*.md` → Treatments\n- `about_clinic.md` → Institutional\n- `price_objections.md` → Objections\n- `disclaimer_*.md` → Compliance\n\n### 4. Priority Tagging\nAdd `priority:high` in file description for high-priority docs.",
        "width": 360,
        "height": 440
      },
      "id": "setup-note",
      "name": "Setup Guide",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [640, -100]
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "List Files from Google Drive",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Files from Google Drive": {
      "main": [
        [
          {
            "node": "Filter Supported Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Supported Files": {
      "main": [
        [
          {
            "node": "Download File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download File": {
      "main": [
        [
          {
            "node": "Parse & Chunk Document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Chunk Document": {
      "main": [
        [
          {
            "node": "Insert into Qdrant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert into Qdrant": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "Generate Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Embeddings": {
      "ai_embedding": [
        [
          {
            "node": "Insert into Qdrant",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "Insert into Qdrant",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Sofia",
      "id": "1"
    },
    {
      "name": "RAG",
      "id": "2"
    },
    {
      "name": "Setup",
      "id": "3"
    },
    {
      "name": "Google Drive",
      "id": "4"
    }
  ],
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "sofia-rag-setup-gdrive"
  }
}

{
  "name": "Knowledge Base Sync (Google Drive â†’ Qdrant)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 6
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Every 6 Hours",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [250, 300]
    },
    {
      "parameters": {
        "operation": "list",
        "folderId": {
          "__rl": true,
          "value": "={{ $env.GOOGLE_DRIVE_KB_FOLDER_ID }}",
          "mode": "id"
        },
        "options": {
          "fields": ["id", "name", "mimeType", "modifiedTime"]
        }
      },
      "id": "list-drive-files",
      "name": "List Google Drive Files",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [450, 300],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "google-drive-creds",
          "name": "Google Drive"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "is-doc-or-text",
              "leftValue": "={{ $json.mimeType }}",
              "rightValue": "application/vnd.google-apps.document",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "filter-docs",
      "name": "Filter Google Docs Only",
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.id }}",
          "mode": "id"
        },
        "options": {
          "googleFileConversion": {
            "conversion": {
              "docsToFormat": "text/plain"
            }
          }
        }
      },
      "id": "download-doc",
      "name": "Download as Text",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [850, 300],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "google-drive-creds",
          "name": "Google Drive"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Chunk the document content\nconst item = $input.first();\nconst fileName = item.json.name || 'unknown';\nconst binaryData = item.binary?.data;\n\nif (!binaryData) {\n  return [{ json: { error: 'No binary data', fileName } }];\n}\n\n// Decode binary to text\nconst content = Buffer.from(binaryData.data, 'base64').toString('utf-8');\n\n// Parse metadata from filename\n// Expected format: category_language_title.gdoc\n// Example: faq_pt_perguntas-frequentes.gdoc\nconst nameParts = fileName.replace('.gdoc', '').split('_');\nconst category = nameParts[0] || 'general';\nconst language = nameParts[1] || 'pt';\nconst title = nameParts.slice(2).join('_') || fileName;\n\n// Chunk the content\nconst CHUNK_SIZE = 500; // words\nconst OVERLAP = 50;\n\nconst words = content.split(/\\s+/).filter(w => w.length > 0);\nconst chunks = [];\n\nlet start = 0;\nwhile (start < words.length) {\n  const end = Math.min(start + CHUNK_SIZE, words.length);\n  const chunkText = words.slice(start, end).join(' ');\n  \n  if (chunkText.trim().length > 50) { // Skip very short chunks\n    chunks.push({\n      content: chunkText,\n      metadata: {\n        category,\n        language,\n        source_file: fileName,\n        chunk_index: chunks.length,\n        title\n      }\n    });\n  }\n  \n  start = end - OVERLAP;\n  if (start >= words.length - OVERLAP) break;\n}\n\nreturn chunks.map(chunk => ({ json: chunk }));"
      },
      "id": "chunk-content",
      "name": "Chunk Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"text-embedding-3-small\",\n  \"input\": {{ JSON.stringify($json.content) }}\n}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 20,
              "batchInterval": 1000
            }
          }
        }
      },
      "id": "generate-embeddings",
      "name": "Generate Embeddings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1250, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "openai-key",
          "name": "OpenAI API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare point for Qdrant\nconst embeddingResponse = $input.first().json;\nconst chunkData = $('Chunk Content').item.json;\n\nconst embedding = embeddingResponse.data?.[0]?.embedding;\n\nif (!embedding) {\n  throw new Error('No embedding returned from OpenAI');\n}\n\n// Generate unique ID based on file + chunk\nconst idString = `${chunkData.metadata.source_file}_${chunkData.metadata.chunk_index}`;\nconst hashCode = (str) => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash);\n};\n\nreturn [{\n  json: {\n    id: hashCode(idString),\n    vector: embedding,\n    payload: {\n      content: chunkData.content,\n      category: chunkData.metadata.category,\n      language: chunkData.metadata.language,\n      source_file: chunkData.metadata.source_file,\n      chunk_index: chunkData.metadata.chunk_index,\n      title: chunkData.metadata.title,\n      indexed_at: new Date().toISOString()\n    }\n  }\n}];"
      },
      "id": "prepare-qdrant-point",
      "name": "Prepare Qdrant Point",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{ $env.QDRANT_URL }}/collections/{{ $env.QDRANT_COLLECTION_NAME }}/points?wait=true",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"points\": [$json]\n}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 50,
              "batchInterval": 500
            }
          }
        }
      },
      "id": "upsert-qdrant",
      "name": "Upsert to Qdrant",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1650, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "qdrant-key",
          "name": "Qdrant API Key"
        }
      }
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "jsCode": "// Summary of sync operation\nconst items = $input.first().json.data || [];\nconst successCount = items.filter(i => i.status === 'ok' || i.result?.status === 'ok').length;\nconst totalCount = items.length;\n\nconst summary = {\n  timestamp: new Date().toISOString(),\n  total_chunks_processed: totalCount,\n  successful_upserts: successCount,\n  failed: totalCount - successCount,\n  status: successCount === totalCount ? 'success' : 'partial'\n};\n\nconsole.log('Knowledge Base Sync Summary:', JSON.stringify(summary));\n\nreturn [{ json: summary }];"
      },
      "id": "create-summary",
      "name": "Create Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.telegram.org/bot{{ $env.TELEGRAM_BOT_TOKEN }}/sendMessage",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"chat_id\": \"{{ $env.TELEGRAM_CHAT_ID }}\",\n  \"text\": \"ðŸ“š *Knowledge Base Sync Complete*\\n\\nâœ… Processed: {{ $json.total_chunks_processed }} chunks\\n{{ $json.status === 'success' ? 'ðŸŸ¢' : 'ðŸŸ¡' }} Status: {{ $json.status }}\\n\\nTimestamp: {{ $json.timestamp }}\",\n  \"parse_mode\": \"Markdown\"\n}",
        "options": {}
      },
      "id": "notify-telegram",
      "name": "Notify Telegram",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "sync-knowledge-base",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "manual-trigger",
      "name": "Manual Trigger (Webhook)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 500]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "id": "respond-manual",
      "name": "Respond to Manual Trigger",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2250, 500]
    }
  ],
  "connections": {
    "Every 6 Hours": {
      "main": [
        [
          {
            "node": "List Google Drive Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger (Webhook)": {
      "main": [
        [
          {
            "node": "List Google Drive Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Google Drive Files": {
      "main": [
        [
          {
            "node": "Filter Google Docs Only",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Google Docs Only": {
      "main": [
        [
          {
            "node": "Download as Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download as Text": {
      "main": [
        [
          {
            "node": "Chunk Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunk Content": {
      "main": [
        [
          {
            "node": "Generate Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embeddings": {
      "main": [
        [
          {
            "node": "Prepare Qdrant Point",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Qdrant Point": {
      "main": [
        [
          {
            "node": "Upsert to Qdrant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert to Qdrant": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "Create Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Summary": {
      "main": [
        [
          {
            "node": "Notify Telegram",
            "type": "main",
            "index": 0
          },
          {
            "node": "Respond to Manual Trigger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "instanceId": "clinic-whatsapp-bot"
  },
  "pinData": {},
  "tags": [
    {
      "name": "knowledge-base",
      "id": "7"
    },
    {
      "name": "sync",
      "id": "8"
    }
  ]
}

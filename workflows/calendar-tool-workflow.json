{
  "name": "Calendar Tool - Sofia Scheduling",
  "meta": {
    "instanceId": "calendar-tool-sofia",
    "templateCredsSetupCompleted": true
  },
  "nodes": [
    {
      "id": "workflow-trigger",
      "name": "When Executed by Another Workflow",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [220, 340],
      "parameters": {},
      "typeVersion": 1.1
    },
    {
      "id": "parse-input",
      "name": "Parse Input",
      "type": "n8n-nodes-base.code",
      "position": [420, 340],
      "parameters": {
        "jsCode": "// Parse the input from the AI agent\nconst input = $input.first().json;\n\n// The AI will send either:\n// { operation: 'check_availability', date: 'YYYY-MM-DD' }\n// { operation: 'book_appointment', datetime: 'YYYY-MM-DDTHH:MM', name: '...', phone: '...' }\n\nconst operation = input.operation || 'check_availability';\nconst requestedDate = input.date || input.datetime?.split('T')[0];\nconst requestedTime = input.datetime;\nconst patientName = input.name || input.patient_name || '';\nconst patientPhone = input.phone || input.patient_phone || '';\n\n// Get Sao Paulo timezone offset\nconst saoPauloOffset = -3;\n\n// Calculate date range (default: next 7 days)\nconst now = new Date();\nconst today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n\nlet startDate, endDate;\nif (requestedDate) {\n  startDate = new Date(requestedDate + 'T00:00:00');\n  endDate = new Date(requestedDate + 'T23:59:59');\n} else {\n  startDate = today;\n  endDate = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);\n}\n\nreturn {\n  operation,\n  requestedDate,\n  requestedTime,\n  patientName,\n  patientPhone,\n  startDate: startDate.toISOString(),\n  endDate: endDate.toISOString(),\n  calendarId: 'primary'\n};"
      },
      "typeVersion": 2
    },
    {
      "id": "route-operation",
      "name": "Route Operation",
      "type": "n8n-nodes-base.switch",
      "position": [620, 340],
      "parameters": {
        "rules": {
          "values": [
            {
              "outputKey": "Check Availability",
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.operation }}",
                    "rightValue": "check_availability"
                  }
                ]
              },
              "renameOutput": true
            },
            {
              "outputKey": "Book Appointment",
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.operation }}",
                    "rightValue": "book_appointment"
                  }
                ]
              },
              "renameOutput": true
            }
          ]
        },
        "options": {}
      },
      "typeVersion": 3.2
    },
    {
      "id": "get-calendar-events",
      "name": "Get Calendar Events",
      "type": "n8n-nodes-base.googleCalendar",
      "position": [860, 220],
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "primary",
          "mode": "id"
        },
        "returnAll": true,
        "options": {
          "timeMin": "={{ $('Parse Input').first().json.startDate }}",
          "timeMax": "={{ $('Parse Input').first().json.endDate }}",
          "singleEvents": true,
          "orderBy": "startTime"
        }
      },
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "google-calendar-creds",
          "name": "Google Calendar"
        }
      },
      "typeVersion": 1.3
    },
    {
      "id": "calculate-available-slots",
      "name": "Calculate Available Slots",
      "type": "n8n-nodes-base.code",
      "position": [1080, 220],
      "parameters": {
        "jsCode": "// Calculate available slots based on existing calendar events\nconst existingEvents = $input.all().map(item => item.json);\nconst parseInput = $('Parse Input').first().json;\n\n// Business hours (Sao Paulo time)\nconst businessHours = {\n  start: 9,  // 9 AM\n  end: 18,   // 6 PM\n  slotDuration: 60,  // 60 minutes per slot\n  lunchStart: 12,\n  lunchEnd: 13\n};\n\n// Days we work (0 = Sunday, 6 = Saturday)\nconst workDays = [1, 2, 3, 4, 5]; // Monday to Friday\n\n// Parse busy times from existing events\nconst busyTimes = existingEvents\n  .filter(event => event.start?.dateTime && event.end?.dateTime)\n  .map(event => ({\n    start: new Date(event.start.dateTime),\n    end: new Date(event.end.dateTime)\n  }));\n\n// Generate available slots for the next 7 days\nconst availableSlots = [];\nconst startDate = new Date(parseInput.startDate);\nconst endDate = new Date(parseInput.endDate);\n\nfor (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {\n  // Skip non-work days\n  if (!workDays.includes(d.getDay())) continue;\n  \n  // Generate slots for this day\n  for (let hour = businessHours.start; hour < businessHours.end; hour++) {\n    // Skip lunch hour\n    if (hour >= businessHours.lunchStart && hour < businessHours.lunchEnd) continue;\n    \n    const slotStart = new Date(d.getFullYear(), d.getMonth(), d.getDate(), hour, 0, 0);\n    const slotEnd = new Date(slotStart.getTime() + businessHours.slotDuration * 60 * 1000);\n    \n    // Skip if slot is in the past\n    if (slotStart < new Date()) continue;\n    \n    // Check if slot conflicts with any existing event\n    const hasConflict = busyTimes.some(busy => \n      (slotStart >= busy.start && slotStart < busy.end) ||\n      (slotEnd > busy.start && slotEnd <= busy.end) ||\n      (slotStart <= busy.start && slotEnd >= busy.end)\n    );\n    \n    if (!hasConflict) {\n      availableSlots.push({\n        date: slotStart.toISOString().split('T')[0],\n        time: `${String(hour).padStart(2, '0')}:00`,\n        datetime: slotStart.toISOString(),\n        formatted: `${slotStart.toLocaleDateString('pt-BR', { weekday: 'long', day: 'numeric', month: 'long' })} as ${String(hour).padStart(2, '0')}:00`\n      });\n    }\n  }\n}\n\n// Group by date for easier reading\nconst slotsByDate = {};\navailableSlots.forEach(slot => {\n  if (!slotsByDate[slot.date]) {\n    slotsByDate[slot.date] = [];\n  }\n  slotsByDate[slot.date].push(slot.time);\n});\n\n// Format response for AI\nconst formattedResponse = Object.entries(slotsByDate)\n  .slice(0, 5)  // Limit to first 5 days with availability\n  .map(([date, times]) => {\n    const dateObj = new Date(date + 'T12:00:00');\n    const dayName = dateObj.toLocaleDateString('pt-BR', { weekday: 'long', day: 'numeric', month: 'long' });\n    return `${dayName}: ${times.join(', ')}`;\n  })\n  .join('\\n');\n\nreturn {\n  success: true,\n  availableSlots: availableSlots.slice(0, 20),  // Return max 20 slots\n  slotsByDate,\n  formattedResponse: formattedResponse || 'Nenhum horario disponivel nos proximos dias.',\n  totalAvailable: availableSlots.length\n};"
      },
      "typeVersion": 2
    },
    {
      "id": "create-calendar-event",
      "name": "Create Calendar Event",
      "type": "n8n-nodes-base.googleCalendar",
      "position": [860, 460],
      "parameters": {
        "operation": "create",
        "calendar": {
          "__rl": true,
          "value": "primary",
          "mode": "id"
        },
        "start": "={{ $('Parse Input').first().json.requestedTime }}",
        "end": "={{ DateTime.fromISO($('Parse Input').first().json.requestedTime).plus({ hours: 1 }).toISO() }}",
        "additionalFields": {
          "summary": "=Consulta - {{ $('Parse Input').first().json.patientName }}",
          "description": "=Consulta agendada via WhatsApp\n\nPaciente: {{ $('Parse Input').first().json.patientName }}\nTelefone: {{ $('Parse Input').first().json.patientPhone }}\n\nAgendado automaticamente pela Sofia.",
          "sendUpdates": "none"
        }
      },
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "google-calendar-creds",
          "name": "Google Calendar"
        }
      },
      "typeVersion": 1.3
    },
    {
      "id": "format-booking-response",
      "name": "Format Booking Response",
      "type": "n8n-nodes-base.code",
      "position": [1080, 460],
      "parameters": {
        "jsCode": "// Format the booking confirmation\nconst event = $input.first().json;\nconst parseInput = $('Parse Input').first().json;\n\nconst startTime = new Date(event.start?.dateTime || parseInput.requestedTime);\nconst formattedDate = startTime.toLocaleDateString('pt-BR', { \n  weekday: 'long', \n  day: 'numeric', \n  month: 'long',\n  year: 'numeric'\n});\nconst formattedTime = startTime.toLocaleTimeString('pt-BR', {\n  hour: '2-digit',\n  minute: '2-digit'\n});\n\nreturn {\n  success: true,\n  eventId: event.id,\n  eventLink: event.htmlLink,\n  patientName: parseInput.patientName,\n  patientPhone: parseInput.patientPhone,\n  appointmentDate: formattedDate,\n  appointmentTime: formattedTime,\n  datetime: event.start?.dateTime || parseInput.requestedTime,\n  formattedResponse: `Consulta agendada com sucesso para ${formattedDate} as ${formattedTime}. O evento foi adicionado ao calendario do Dr. Guilherme.`\n};"
      },
      "typeVersion": 2
    },
    {
      "id": "sticky-note",
      "name": "Calendar Tool Info",
      "type": "n8n-nodes-base.stickyNote",
      "position": [120, 60],
      "parameters": {
        "color": 7,
        "width": 500,
        "height": 200,
        "content": "## Calendar Tool Sub-Workflow\n\nThis workflow is called by Sofia AI Agent via toolWorkflow.\n\n**Operations:**\n1. `check_availability` - Returns available appointment slots\n   - Input: `{ operation: 'check_availability', date?: 'YYYY-MM-DD' }`\n   - Output: Available slots formatted for display\n\n2. `book_appointment` - Creates a calendar event\n   - Input: `{ operation: 'book_appointment', datetime: 'ISO', name: '...', phone: '...' }`\n   - Output: Confirmation with event details\n\n**Required Credential:**\n- `google-calendar-creds` (Google Calendar OAuth2)"
      },
      "typeVersion": 1
    }
  ],
  "connections": {
    "When Executed by Another Workflow": {
      "main": [[{"node": "Parse Input", "type": "main", "index": 0}]]
    },
    "Parse Input": {
      "main": [[{"node": "Route Operation", "type": "main", "index": 0}]]
    },
    "Route Operation": {
      "main": [
        [{"node": "Get Calendar Events", "type": "main", "index": 0}],
        [{"node": "Create Calendar Event", "type": "main", "index": 0}]
      ]
    },
    "Get Calendar Events": {
      "main": [[{"node": "Calculate Available Slots", "type": "main", "index": 0}]]
    },
    "Create Calendar Event": {
      "main": [[{"node": "Format Booking Response", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Sofia",
      "id": "1"
    },
    {
      "name": "Calendar",
      "id": "10"
    },
    {
      "name": "Tool",
      "id": "11"
    }
  ],
  "pinData": {}
}
